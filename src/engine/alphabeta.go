package engine

import (
	"github.com/Droanox/ChessEngineAI/src/board"
	"github.com/Droanox/ChessEngineAI/src/eval"
)

func alphabeta(alpha int, beta int, depth int, flag int, cb *board.ChessBoard) int {
	// hashFlag is used to store the type of the hash entry
	// we dont know the type yet, so we set it to hashFlagAlpha
	var hashFlag int = hashFlagAlpha

	// score is used to store the eval of the position
	var score int

	// pvNode is used to determine if the node is a PV node
	var pvNode bool = beta-alpha > 1

	if board.Ply > 0 && board.IsRepetition() {
		return 0
	}

	// bestMove is used to store the best move
	var bestMove board.Move

	// Transposition Table (TT)
	if score := ReadTT(alpha, beta, depth, &bestMove); score != noHash && !pvNode {
		return score
	}

	// pvLength[board.Ply] is used to store the length of the principal variation
	pvLength[board.Ply] = board.Ply

	// when the depth is 0, we call quiescence search to search for captures
	if depth == 0 {
		return quiescence(alpha, beta, cb)
	}

	// increment the number of nodes searched
	nodes++

	// Mate Distance Pruning (MDP)
	// https://www.chessprogramming.org/Mate_Distance_Pruning
	if alpha < -MateValue+board.Ply-1 {
		alpha = -MateValue + board.Ply
	}
	if beta > MateValue-board.Ply {
		beta = MateValue - board.Ply
	}
	if alpha >= beta {
		return alpha
	}

	// Check if the side to move is in check
	// if it is, we increase the depth by 1 Check Extension
	// https://www.chessprogramming.org/Check_Extensions
	var isChecked bool = cb.IsInCheck()
	if isChecked {
		depth++
	}

	// legalMovesNum is used to determine if the position is a checkmate or a stalemate
	var legalMoveAvailable bool = false

	// Null Move Pruning (NMP)
	// https://www.chessprogramming.org/Null_Move_Pruning
	if (depth >= nullMoveDepth) && (!isChecked) && !eval.IsEndGame(*cb) && board.Ply > 0 && flag != NullMovePruningSearch {
		cb.MakeMoveNull()
		score = -alphabeta(-beta, -beta+1, depth-1-nullMoveReduction, NullMovePruningSearch, cb)
		cb.MakeBoard()

		// check if the search should be stopped, time is checked concurrently
		if IsStopped {
			return 0
		}

		if score >= beta {
			return beta
		}
	}

	// movelist is used to store the list of moves generated by the GenerateMoves function
	var moveList = []board.Move{}
	// generate all the moves
	cb.GenerateMoves(&moveList)

	// Move ordering
	// https://www.chessprogramming.org/Move_Ordering
	scoreMoves(&moveList, bestMove)

	// search through the moves
	for i := 0; i < len(moveList); i++ {
		pickMove(&moveList, i)

		if !cb.MakeMove(moveList[i]) {
			continue
		}

		// change legalmove for checkmate and stalemate detection
		legalMoveAvailable = true

		// Principal Variation Search (PVS) and Late Move Reduction (LMR)
		// https://www.chessprogramming.org/Principal_Variation_Search
		// https://www.chessprogramming.org/Late_Move_Reductions
		// full depth search
		if i == 0 {
			score = -alphabeta(-beta, -alpha, depth-1, StandardSearch, cb)
		} else {
			// if the move satisfies the LMR conditions, we search deeper
			// LMR
			// reduction := 0
			if (depth >= reductionLimit) &&
				(i >= fullDepthMoves) &&
				((moveList[i].GetMoveFlags() & (board.MoveCaptures | board.MoveKnightPromotion)) == 0) &&
				!isChecked &&
				!cb.IsInCheck() &&
				killerMoves[0][board.Ply] != moveList[i] &&
				killerMoves[1][board.Ply] != moveList[i] {
				if depth >= 6 {
					score = -alphabeta(-alpha-1, -alpha, depth/3, StandardSearch, cb)
				} else {
					score = -alphabeta(-alpha-1, -alpha, depth-2, StandardSearch, cb)
				}
				// fmt.Println(int(math.Sqrt(float64(depth-1)) + math.Sqrt(float64(i-1))))
				// reduction = Max(0, int(math.Sqrt(float64(depth-1))+math.Sqrt(float64(i-1))))
				// reduction = Max(0, Min(reduction, depth-1))
				// score = -alphabeta(-alpha-1, -alpha, depth-reduction, StandardSearch, cb)
			} else {
				score = alpha + 1
			}
			// if the move fails high, we search deeper
			// PVS
			if score > alpha {
				score = -alphabeta(-alpha-1, -alpha, depth-1, PVSSearch, cb)
				// if the move fails high, we search deeper again to confirm the move is good and not a fluke
				if (score > alpha) && (score < beta) {
					score = -alphabeta(-beta, -alpha, depth-1, PVSSearch, cb)
				}
			}
		}

		// unmake the move
		cb.MakeBoard()

		// check if the search should be stopped, time is checked concurrently
		if IsStopped {
			return 0
		}

		// found a better move
		if score > alpha {
			hashFlag = hashFlagExact

			bestMove = moveList[i]

			alpha = score

			pvTable[board.Ply][board.Ply] = bestMove

			for j := board.Ply + 1; j < pvLength[board.Ply+1]; j++ {
				pvTable[board.Ply][j] = pvTable[board.Ply+1][j]
			}
			pvLength[board.Ply] = pvLength[board.Ply+1]

			// fails high
			if score >= beta {
				WriteTT(beta, depth, hashFlagBeta, bestMove)

				if (moveList[i].GetMoveFlags() & (board.MoveCaptures | board.MoveKnightPromotion)) == 0 {
					if score > -MateValue && score < -MateScore {
						mateKillerMoves[board.Ply] = moveList[i]
					} else if killerMoves[0][board.Ply] != moveList[i] {
						killerMoves[1][board.Ply] = killerMoves[0][board.Ply]
						killerMoves[0][board.Ply] = moveList[i]
					} else {
						historyMoves[board.SideToMove][moveList[i].GetMoveStart()][moveList[i].GetMoveEnd()] += 1 << depth
					}
				}
				// if i > 0 && (moveList[i].GetMoveFlags()&board.MoveCaptures) == 0 {
				// counterMoves[board.SideToMove][moveList[i-1].GetMoveStart()][moveList[i-1].GetMoveEnd()] = moveList[i]
				// }

				return beta
			}
		}
	}

	// check for checkmate and stalemate
	if !legalMoveAvailable {
		if isChecked {
			return -MateValue + board.Ply
		} else {
			return 0
		}
	}

	WriteTT(alpha, depth, hashFlag, bestMove)

	// fails low
	return alpha
}
